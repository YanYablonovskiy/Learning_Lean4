/-
Mutual Recursion
Lean also supports mutual recursive definitions.

The syntax is similar to that for mutual inductive types.

Here is an example
-/
mutual
  def even : Nat → Bool
    | 0   => true
    | n+1 => odd n

  def odd : Nat → Bool --just counts steps to get to 0; depending which step
                       -- determines parity; eg for 3, last step for even 3 lands in odd 0
    | 0   => false
    | n+1 => even n
end

example : even (a + 1) = odd a := by
  simp [even]

example : odd (a + 1) = even a := by
  simp [odd]

theorem even_eq_not_odd : ∀ a, even a = not (odd a) := by
  intro a; induction a
  . simp [even]; simp [odd] --goal: even 0 = !odd 0 first simp;
                            --reduces to false = !odd 0; then reduces to false = false
  . simp [even, odd, *]
    --goal: even (n + 1) = !odd (n + 1); given for n;
    --first simp changes to odd n = !odd (n+1)
    --second simp changes to odd n = !even n
    --not on both sides ?

--my version

theorem even_eq_not_odd' : ∀ a, even a = not (odd a) := by
  intro a; induction a
  . simp [even]; simp [odd] --goal: even 0 = !odd 0 first simp;
                            --reduces to false = !odd 0; then reduces to false = false
  . case succ n ih => simp [even, odd]; apply Bool.not_eq_eq_eq_not.mp; exact Eq.comm.mp ih
    --goal: even (n + 1) = !odd (n + 1); given for n;
    --first simp changes to odd n = !odd (n+1)
    --second simp changes to odd n = !even n
    --not on both sides ?



#check Bool.not_eq_eq_eq_not.mp

/-
What makes this a mutual definition is that even is defined recursively in terms of odd,
while odd is defined recursively in terms of even.

Under the hood, this is compiled as a single recursive definition.

The internally defined function takes, as argument, an element of a sum type,
either an input to even, or an input to odd.

It then returns an output appropriate to the input.

To define that function, Lean uses a suitable well-founded measure.

The internals are meant to be hidden from users; the canonical way to
make use of such definitions is to use simp (or unfold), as we did above.

Mutual recursive definitions also provide natural ways of working with
mutual and nested inductive types.

Recall the definition of Even and Odd as mutual
inductive predicates as presented before.
-/

#reduce even
--fun x ↦ (Nat.rec ⟨⟨true, false⟩, PUnit.unit⟩ (fun n n_ih ↦ ⟨⟨n_ih.1.2, n_ih.1.1⟩, n_ih⟩) x).1.1
#check  PUnit.unit


mutual
  inductive Even : Nat → Prop where
    | even_zero : Even 0 --covers the 0 indice
    | even_succ : ∀ n, Odd n → Even (n + 1) --covers the succ indice

  inductive Odd : Nat → Prop where
    | odd_succ : ∀ n, Even n → Odd (n + 1) --odd 0 not inhabited? by design?
end


/-
The constructors, even_zero, even_succ, and odd_succ provide positive means for showing that a number
is even or odd.

We need to use the fact that the inductive type is generated by these constructors to know that zero is not odd,
and that the latter two implications reverse.

As usual, the constructors are kept in a namespace that is named after the type being defined,
and the command open Even Odd allows us to access them more conveniently.
-/

open Even Odd

theorem not_odd_zero : ¬ Odd 0 :=
  fun h => nomatch h

theorem even_of_odd_succ : ∀ n, Odd (n + 1) → Even n
  | _, odd_succ n h => h

theorem odd_of_even_succ : ∀ n, Even (n + 1) → Odd n
  | _, even_succ n h => h

/-
For another example, suppose we use a nested inductive type to define a set of terms inductively,
so that a term is either a constant (with a name given by a string), or the result of applying a
constant to a list of constants.
-/
inductive Term where
  | const : String → Term
  | app   : String → List Term → Term

/-
We can then use a mutual recursive definition to count the number of constants occurring in a term,
as well as the number occurring in a list of terms.
-/
namespace Term

mutual
  def numConsts : Term → Nat
    | const _ => 1
    | app _ cs => numConstsLst cs

  def numConstsLst : List Term → Nat
    | [] => 0
    | c :: cs => numConsts c + numConstsLst cs --decreasing, so induction?
end

def sample := app "f" [app "g" [const "x"], const "y"]

#eval numConsts sample

#reduce numConsts



/-
As a final example, we define a function replaceConst a b e that replaces a constant a with b in a term e,
and then prove the number of constants is the same.

Note that, our proof uses mutual recursion (aka induction).


-/

mutual
  def replaceConst (a b : String) : Term → Term
    | const c => if a == c then const b else const c --returns b if the term is equal to a, otherwise returns the term
    | app f cs => app f (replaceConstLst a b cs) --if of the other contructor, contructs term with the head and replacing
                                                 --using other function

  def replaceConstLst (a b : String) : List Term → List Term
    | [] => []
    | c :: cs => replaceConst a b c :: replaceConstLst a b cs
end

mutual
  theorem numConsts_replaceConst (a b : String) (e : Term)
            : numConsts (replaceConst a b e) = numConsts e := by
    match e with
    | const c => simp [replaceConst]; split <;> simp [numConsts]
    | app f cs => simp [replaceConst, numConsts, numConsts_replaceConstLst a b cs]

  theorem numConsts_replaceConstLst (a b : String) (es : List Term)
            : numConstsLst (replaceConstLst a b es) = numConstsLst es := by
    match es with
    | [] => simp [replaceConstLst, numConstsLst]
    | c :: cs =>
      simp [replaceConstLst, numConstsLst, numConsts_replaceConst a b c,
            numConsts_replaceConstLst a b cs]
end

end Term
