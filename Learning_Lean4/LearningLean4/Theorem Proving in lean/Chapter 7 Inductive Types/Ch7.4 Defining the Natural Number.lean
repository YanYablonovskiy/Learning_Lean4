/-
The inductively defined types we have seen so far are "flat": constructors wrap data and insert it into a type,
and the corresponding recursor unpacks the data and acts on it.

Things get much more interesting when the constructors act on elements of the very type being defined.

A canonical example is the type Nat of natural numbers:
-/
namespace Hidden

inductive Nat₁ where
  | zero : Nat₁
  | succ : Nat₁ → Nat₁
  deriving Repr
/-
There are two constructors.

We start with zero : Nat; it takes no arguments, so we have it from the start.

In contrast, the constructor succ can only be applied to a previously constructed Nat.

Applying it to zero yields succ zero : Nat. Applying it again yields
succ (succ zero) : Nat, and so on.

Intuitively, Nat is the "smallest" type with these constructors, meaning that it is exhaustively
(and freely) generated by starting with zero and applying succ repeatedly.
-/


/-
As before, the recursor for Nat is designed to define a dependent function f from Nat to any domain, that is, an element f of (n : Nat) → motive n for some
motive : Nat → Sort u.

It has to handle two cases: the case where the input is zero, and the case where the
input is of the form succ n for some n : Nat.

In the first case, we simply specify a target value with the appropriate type, as before.

In the second case, however, the recursor can assume that a value of f at n has already been computed.

As a result, the next argument to the recursor specifies a value for f (succ n) in terms of n and f n.

If we check the type of the recursor,
-/
#check @Nat₁.rec

/-
you find the following:
-/

/-
  {motive : Nat → Sort u}
  → motive Nat.zero
  → ((n : Nat) → motive n → motive (Nat.succ n))
  → (t : Nat) → motive t
-/

#check @Nat₁.recOn
#check @Nat.strongRecOn

/-
The implicit argument, motive, is the codomain of the function being defined.

In type theory it is common to say motive is the motive for the elimination/recursion,
since it describes the kind of object we wish to construct.

The next two arguments specify how to compute the zero and successor cases, as described above.

They are also known as the minor premises.

Finally, the t : Nat, is the input to the function. It is also known as the major premise.
-/

#check @Nat.recOn

/-
The Nat.recOn is similar to Nat.rec but the major premise occurs before the minor premises.
-/

/-
@Nat.recOn :
  {motive : Nat → Sort u}
  → (t : Nat)
  → motive Nat.zero
  → ((n : Nat) → motive n → motive (Nat.succ n))
  → motive t
-/


/-
Consider, for example, the addition function add m n on the natural numbers.

Fixing m, we can define addition by recursion on n.

In the base case, we set add m zero to m.

In the successor step, assuming the value add m n is already determined,
we define add m (succ n) to be succ (add m n).
-/



end Hidden

open Nat

def add (m n : Nat) : Nat :=
  match n with
  | Nat.zero   => m
  | Nat.succ n => Nat.succ (add m n)

#eval add (Nat.succ (Nat.succ Nat.zero)) (Nat.succ Nat.zero)

/-
It is useful to put such definitions into a namespace, Nat.

We can then go on to define familiar notation in that namespace.

The two defining equations for addition now hold definitionally:
-/
instance : Add Nat where
  add := add

theorem add_zero (m : Nat) : m + zero = m := rfl
theorem add_succ₁ (m n : Nat) : m + succ n = succ (m + n) := rfl

/-
We will explain how the instance command works in Chapter Type Classes.

In the examples below, we will use Lean's version of the natural numbers.

Proving a fact like zero + m = m, however, requires a proof by induction.

As observed above, the induction principle is just a special case of the recursion principle,
when the codomain motive n is an element of Prop.

It represents the familiar pattern of an inductive proof: to prove ∀ n, motive n, first prove motive 0,
and then, for arbitrary n, assume ih : motive n and prove motive (succ n).
-/


theorem zero_add (n : Nat) : 0 + n = n :=
  Nat.recOn (motive := fun x => 0 + x = x) --defining codomain being Prop 0 + x = x
   n
   (show 0 + 0 = 0 from rfl)
   (fun (n : Nat) (ih : 0 + n = n) =>
    show 0 + succ n = succ n from
    calc 0 + succ n
      _ = succ (0 + n) := rfl --putting succ outside the brackets
      _ = succ n       := by rw [ih])

/-
Notice that, once again, when Nat.recOn is used in the context of a proof, it is really the induction principle in disguise.

The rewrite and simp tactics tend to be very effective in proofs like these.

In this case, each can be used to reduce the proof to:
-/

theorem zero_add_tactic (n : Nat) : 0 + n = n :=
  Nat.recOn (motive := fun x => 0 + x = x) n
    rfl
    (fun n ih => by simp [add_succ₁, ih])

/-
As another example, let us prove the associativity of addition, ∀ m n k, m + n + k = m + (n + k).

(The notation +, as we have defined it, associates to the left, so m + n + k is really (m + n) + k.)

The hardest part is figuring out which variable to do the induction on.

Since addition is defined by recursion on the second argument, k is a good guess,
and once we make that choice the proof almost writes itself:
-/

theorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k --we want to prove the Prop : m + n + k = m + (n + k)
                                                           --inductively
    (show m + n + 0 = m + (n + 0) from rfl)   --show the base case
    (fun k (ih : m + n + k = m + (n + k)) => --inductive hypothesis
      show m + n + succ k = m + (n + succ k) from
      calc m + n + succ k
        _ = succ (m + n + k)   := rfl --taking succ out
        _ = succ (m + (n + k)) := by rw [ih] --using the induction hypothesis
        _ = m + succ (n + k)   := rfl -- taking succ out
        _ = m + (n + succ k)   := rfl) --taking succ out again

--my one

example (m n k: Nat):  m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k --we want to prove the Prop : m + n + k = m + (n + k)
                                                           --inductively
    (show m + n + 0 = m + (n + 0) from rfl)   --show the base case
    (fun k (ih : m + n + k = m + (n + k)) => --inductive hypothesis
      show m + n + succ k = m + (n + succ k) from
      calc m + n + succ k
        _ = succ (m + n + k)   := rfl --taking succ out
        _ = succ (m + (n + k)) := by rw [ih] --using the induction hypothesis -- taking succ out
        _ = m + (n + succ k)   := rfl) --taking succ out again

/-
Once again, you can reduce the proof to:
-/
open Nat
--set_option diagnostics true
--set_option maxRecDepth

theorem add_assoc_tactic (m n k : Nat) : m + n + k = m + (n + k) :=
  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k
    rfl
    (fun k (ih : m + n + k = m + (n + k)) => by admit ) --theirs simp [Nat.add_succ, ih]
    --couldnt get theirs to work
#check Nat.add_succ

/-
Suppose we try to prove the commutativity of addition.

Choosing induction on the second argument, we might begin as follows:
-/
example (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x => m + x = x + m) n
   (show m + 0 = 0 + m by rw [zero_add, add_zero]) --rewrite m+0 as m and 0+m as m
   (fun (n : Nat) (ih : m + n = n + m) =>
    show m + succ n = succ n + m from
    calc m + succ n
      _ = succ (m + n) := rfl --take succ outside
      _ = succ (n + m) := by rw [ih] --rewriting m+n and n+m
      _ = succ n + m   := sorry)

/-
At this point, we see that we need another supporting fact, namely, that succ (n + m) = succ n + m.

You can prove this by induction on m:
-/
theorem succ_add (n m : Nat) : succ n + m = succ (n + m) :=
  Nat.recOn (motive := fun x => succ n + x = succ (n + x)) m
    (show succ n + 0 = succ (n + 0) from rfl)
    (fun (m : Nat) (ih : succ n + m = succ (n + m)) =>
     show succ n + succ m = succ (n + succ m) from
     calc succ n + succ m
       _ = succ (succ n + m)   := rfl
       _ = succ (succ (n + m)) := by rw [ih]
       _ = succ (n + succ m)   := rfl)

theorem add_comm (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x => m + x = x + m) n
   (show m + 0 = 0 + m by rw [zero_add, add_zero]) --rewrite m+0 as m and 0+m as m
   (fun (n : Nat) (ih : m + n = n + m) =>
    show m + succ n = succ n + m from
    calc m + succ n
      _ = succ (m + n) := rfl --take succ outside
      _ = succ (n + m) := by rw [ih] --rewriting m+n and n+m
      _ = succ n + m   := by rw [_root_.succ_add])


/-
You can then replace the sorry in the previous proof with succ_add.

Yet again, the proofs can be compressed:
-/

open Nat
theorem succ_add_tactic (n m : Nat) : succ n + m = succ (n + m) :=
  Nat.recOn (motive := fun x => succ n + x = succ (n + x)) m
    rfl --their versions wont work..
    (fun m ih => by simp at *;  by admit-- rw [Nat.add_assoc n 1 (m+1)])

theorem add_comm_tactic (m n : Nat) : m + n = n + m :=
  Nat.recOn (motive := fun x => m + x = x + m) n
    (by simp [add_zero,zero_add])
    (fun m ih => by admit -- by simp [add_succ, _root_.succ_add, ih,←add_assoc,add_assoc])
