/-
We have seen that Lean's formal foundation includes basic types, Prop, Type 0, Type 1, Type 2, ..., and allows for the formation of dependent function types,
(x : α) → β.

In the examples, we have also made use of additional types like Bool, Nat, and Int, and type constructors,
like List, and product, ×.

In fact, in Lean's library, every concrete type other than the universes and every type constructor other than
dependent arrows is an instance of a general family of type constructions known as inductive types.

It is remarkable that it is possible to construct a substantial edifice of mathematics based on nothing
more than the type universes, dependent arrow types, and inductive types; everything else follows from those.

Intuitively, an inductive type is built up from a specified list of constructors.

In Lean, the syntax for specifying such a type is as follows:
-/


/-
inductive Foo where
  | constructor₁ : ... → Foo
  | constructor₂ : ... → Foo
  ...
  | constructorₙ : ... → Foo
-/

/-
The intuition is that each constructor specifies a way of building new objects of Foo, possibly from previously constructed values.

The type Foo consists of nothing more than the objects that are constructed in this way.

The first character | in an inductive declaration is optional.

We can also separate constructors using a comma instead of |.

We will see below that the arguments of the constructors can include objects of type Foo,
subject to a certain "positivity" constraint, which guarantees that elements of Foo are built from the bottom up.

Roughly speaking, each ... can be any arrow type constructed from Foo and previously defined types,
in which Foo appears, if at all, only as the "target" of the dependent arrow type.

We will provide a number of examples of inductive types.

We will also consider slight generalizations of the scheme above, to mutually defined inductive types,
and so-called inductive families.

As with the logical connectives, every inductive type comes with introduction rules,
which show how to construct an element of the type, and elimination rules, which show how
to "use" an element of the type in another construction.

The analogy to the logical connectives should not come as a surprise; as we will see below,
they, too, are examples of inductive type constructions.

You have already seen the introduction rules for an inductive type: they are just the constructors
that are specified in the definition of the type.

The elimination rules provide for a principle of recursion on the type, which includes, as a special case,
a principle of induction as well.

In the next chapter, we will describe Lean's function definition package, which provides even more convenient
ways to define functions on inductive types and carry out inductive proofs.

But because the notion of an inductive type is so fundamental, we feel it is important to start
with a low-level, hands-on understanding.

We will start with some basic examples of inductive types, and work our way up to
more elaborate and complex examples.
-/

/-
The simplest kind of inductive type is a type with a finite, enumerated list of elements.
-/
inductive Weekday where
  | sunday : Weekday
  | monday : Weekday
  | tuesday : Weekday
  | wednesday : Weekday
  | thursday : Weekday
  | friday : Weekday
  | saturday : Weekday -- 7 constructors?





/-
The inductive command creates a new type, Weekday.

The constructors all live in the Weekday namespace.
-/

#check Weekday.sunday
#check Weekday.monday

open Weekday

#check sunday
#check monday

/-
You can omit : Weekday when declaring the Weekday inductive type.
-/
inductive Weekdayₛ where
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday

/-
Think of sunday, monday, ... , saturday as being distinct elements of Weekday,
with no other distinguishing properties.

The elimination principle, Weekday.rec, is defined along with the type Weekday and its constructors.

It is also known as a recursor, and it is what makes the type "inductive": it allows us to define a
function on Weekday by assigning values corresponding to each constructor.

The intuition is that an inductive type is exhaustively generated by the constructors,
and has no elements beyond those they construct.

We will use the match expression to define a function from Weekday to the natural numbers:
-/

open Weekday

def numberOfDay (d : Weekday) : Nat :=
  match d with
  | sunday    => 1
  | monday    => 2
  | tuesday   => 3
  | wednesday => 4
  | thursday  => 5
  | friday    => 6
  | saturday  => 7

#eval numberOfDay Weekday.sunday  -- 1
#eval numberOfDay Weekday.monday  -- 2
#eval numberOfDay Weekday.tuesday -- 3

--
def numberOfDayTactic (d: Weekdayₛ): Nat := by
cases d
. case sunday => exact 1
. case monday => exact 2
. case tuesday => exact 3
. case wednesday => exact 4
. case thursday => exact 5
. case friday => exact 6
. case saturday => exact 7

/-
Note that the match expression is compiled using the recursor Weekday.rec generated
when you declare the inductive type.
-/



#print numberOfDay
-- ... numberOfDay.match_1
#print numberOfDay.match_1
-- ... Weekday.casesOn ...
#print Weekday.casesOn
-- ... Weekday.rec ...
#check @Weekday.rec
/-
@Weekday.rec.{u}
 : {motive : Weekday → Sort u} →
    motive Weekday.sunday →
    motive Weekday.monday →
    motive Weekday.tuesday →
    motive Weekday.wednesday →
    motive Weekday.thursday →
    motive Weekday.friday →
    motive Weekday.saturday →
    (t : Weekday) → motive t
-/

/-
When declaring an inductive datatype, you can use deriving Repr to instruct Lean to generate a function that
converts Weekday objects into text.

This function is used by the #eval command to display Weekday objects.
-/
inductive WeekdayRepr where
  | sunday
  | monday
  | tuesday
  | wednesday
  | thursday
  | friday
  | saturday
  deriving Repr

open WeekdayRepr

#eval WeekdayRepr.tuesday   -- Weekday.tuesday

/-
It is often useful to group definitions and theorems related to a structure in a namespace with the same name.

For example, we can put the numberOfDay function in the Weekday namespace.

We are then allowed to use the shorter name when we open the namespace.

We can define functions from Weekday to Weekday:
-/

namespace WeekdayRepr
def next (d : WeekdayRepr) : WeekdayRepr :=
  match d with
  | sunday    => monday
  | monday    => tuesday
  | tuesday   => wednesday
  | wednesday => thursday
  | thursday  => friday
  | friday    => saturday
  | saturday  => sunday

def previous (d : WeekdayRepr) : WeekdayRepr :=
  match d with
  | sunday    => saturday
  | monday    => sunday
  | tuesday   => monday
  | wednesday => tuesday
  | thursday  => wednesday
  | friday    => thursday
  | saturday  => friday

#eval next (next tuesday)      -- Weekday.thursday
#eval next (previous tuesday)  -- Weekday.tuesday

example : next (previous tuesday) = tuesday :=
  rfl

end WeekdayRepr

/-
How can we prove the general theorem that next (previous d) = d for any Weekday d?

You can use match to provide a proof of the claim for each constructor:
-/

open WeekdayRepr

def next_previous (d : WeekdayRepr) : next (previous d) = d :=
  match d with
  | WeekdayRepr.sunday    => rfl --using rfl on next (previous sunday) to get sunday = sunday
  | WeekdayRepr.monday    => rfl
  | WeekdayRepr.tuesday   => rfl
  | WeekdayRepr.wednesday => rfl
  | WeekdayRepr.thursday  => rfl
  | WeekdayRepr.friday    => rfl
  | WeekdayRepr.saturday  => rfl

/-
Using a tactic proof, we can be even more concise:
-/
def next_previous_tactic (d : WeekdayRepr) : next (previous d) = d := by
  cases d <;> rfl

--my version
theorem next_previous_tactic_thm: (∀ d: WeekdayRepr, next (previous d) = d) := by
intro hd
cases hd <;> rfl


/-
Tactics for Inductive Types below will introduce additional tactics that are specifically
designed to make use of inductive types.

Notice that, under the propositions-as-types correspondence,
we can use match to prove theorems as well as define functions.

In other words, under the propositions-as-types correspondence,
the proof by cases is a kind of definition by cases, where
what is being "defined" is a proof instead of a piece of data.

The Bool type in the Lean library is an instance of enumerated type.
-/


/-
To run these examples, we put them in a namespace called Hidden, so that a name like Bool does not conflict with
the Bool in the standard library.

This is necessary because these types are part of the Lean "prelude" that is automatically imported when
the system is started.
-/
namespace Hidden

inductive Bool where
  | false : Bool
  | true  : Bool


end Hidden
/-
As an exercise, you should think about what the introduction and elimination rules for these types do.

As a further exercise, we suggest defining boolean operations and, or, not on the Bool type,
and verifying common identities.

Note that you can define a binary operation like and using match:
-/

def and (a b : Bool) : Bool :=
  match a with
  | true  => b
  | false => false

/-
Similarly, most identities can be proved by introducing suitable match, and then using rfl.
-/
