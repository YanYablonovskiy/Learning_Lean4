/-
Inductive Families:

We are almost done describing the full range of inductive definitions accepted by Lean.

So far, you have seen that Lean allows you to introduce inductive types with any number
of recursive constructors.

In fact, a single inductive definition can introduce an indexed family of inductive types,
in a manner we now describe.

An inductive family is an indexed family of types defined by a simultaneous induction
of the following form:
-/

/-
inductive foo : ... → Sort u where
  | constructor₁ : ... → foo ...
  | constructor₂ : ... → foo ...
  ...
  | constructorₙ : ... → foo ...
-/

/-
In contrast to an ordinary inductive definition, which constructs an element of some Sort u,
the more general version constructs a function ... → Sort u, where "..." denotes a sequence
of argument types, also known as indices.

Each constructor then constructs an element of some member of the family.

One example is the definition of Vector α n, the type of vectors of elements of
α of length n:
-/
inductive Vector (α : Type u) : Nat → Type u where
  | nil  : Vector α 0 --creates the 0 vector
  | cons : α → {n : Nat} → Vector α n → Vector α (n+1)
  --contructs a vector for any other n inductively

/-
Notice that the cons constructor takes an element of Vector α n and returns an element of Vector α (n+1),
thereby using an element of one member of the family to build an element of another.

A more exotic example is given by the definition of the equality type in Lean:
-/

namespace Hidden
inductive Eq {α : Sort u} (a : α) : α → Prop where
  | refl : Eq a a

end Hidden

/-
For each fixed α : Sort u and a : α, this definition constructs a family of types Eq a x,
indexed by x : α.

Notably, however, there is only one constructor, refl, which is an element of Eq a a.

Intuitively, the only way to construct a proof of Eq a x is to use reflexivity,
in the case where x is a.

Note that Eq a a is the only inhabited type in the family of types Eq a x.

The elimination principle generated by Lean is as follows:
-/
universe u v

#check (@Eq.rec : {α : Sort u} → {a : α} → {motive : (x : α) → a = x → Sort v}
                  → motive a rfl → {b : α} → (h : a = b) → motive b h) --rfl using Eq.refl

/-
It is a remarkable fact that all the basic axioms for equality follow from the constructor,
refl, and the eliminator, Eq.rec. The definition of equality is atypical, however; see the discussion in Section Axiomatic Details.

The recursor Eq.rec is also used to define substitution:
-/

theorem subst {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  Eq.rec (motive := fun x _ => p x) h₂ h₁

/-
You can also define subst using match.
-/
theorem subst_1 {α : Type u} {a b : α} {p : α → Prop} (h₁ : Eq a b) (h₂ : p a) : p b :=
  match h₁ with
  | rfl => h₂

/-
Actually, Lean compiles the match expressions using a definition based on Eq.rec.
-/
set_option pp.all true
#print subst
  -- ... subst.match_1 ...
#print subst_1.match_1
  -- ... Eq.casesOn ...
#print Eq.casesOn
  -- ... Eq.rec ...

/-
Using the recursor or match with h₁ : a = b, we may assume a and b are the same,
in which case, p b and p a are the same.

It is not hard to prove that Eq is symmetric and transitive.

In the following example, we prove symm and leave as exercises the theorems trans and congr (congruence).
-/

theorem symm {α : Type u} {a b : α} (h : Eq a b) : Eq b a :=
  match h with
  | rfl => rfl

-- theorem trans {α : Type u} {a b c : α} (h₁ : Eq a b) (h₂ : Eq b c) : Eq a c :=
--   sorry

-- theorem congr {α β : Type u} {a b : α} (f : α → β) (h : Eq a b) : Eq (f a) (f b) :=
--   sorry

/-
In the type theory literature, there are further generalizations of inductive definitions,
for example, the principles of induction-recursion and induction-induction.

These are not supported by Lean.
-/
