/-
In addition to apply and exact, another useful tactic is intro, which introduces a hypothesis.

What follows is an example of an identity from propositional logic that we proved in a
previous chapter, now proved using tactics.

-/

example (p q r : Prop) : p ∧ (q ∨ r) ↔ (p ∧ q) ∨ (p ∧ r) := by
  apply Iff.intro --finds a suffices for iff.intro, in this case mp and mpr
  . intro h --entering case mp:p ∧ (q ∨ r) → (p ∧ q) ∨ (p ∧ r)
    apply Or.elim (And.right h) --applying Or.elim to (q ∨ r)
    . intro hq --entering case q → (p ∧ q) ∨ (p ∧ r)
      apply Or.inl --applying or.inl meaning we need p ∧ q
      apply And.intro --applying And.intro to p∧q to get cases p and q
      . exact And.left h --prove p
      . exact hq --prove q
    . intro hr --entering case r → (p ∧ q) ∨ (p ∧ r)
      apply Or.inr -- this time we need p ∧ r
      apply And.intro --deconstructing into goals p and r
      . exact And.left h --show p
      . exact hr --show r
  . intro h --entering case mpr: (p ∧ q) ∨ (p ∧ r) → p ∧ (q ∨ r)
    apply Or.elim h --applying Or elim to (p ∧ q) ∨ (p ∧ r)
    . intro hpq --entering case (p ∧ q) →  p ∧ (q ∨ r)
      apply And.intro --deconstructing into goals p and (q ∨ r)
      . exact And.left hpq  --show p
      . apply Or.inl --deconstruct to q
        exact And.right hpq --show q
    . intro hpr --entering case (p ∧ r) →  p ∧ (q ∨ r)
      apply And.intro --into goals p and q ∨ r
      . exact And.left hpr --show p
      . apply Or.inr --into goal r
        exact And.right hpr --show r

/-
The intro command can more generally be used to introduce a variable of any type:
-/
example (α : Type) : α → α := by
  intro a --introducing element of Type α
  exact a --showing α

example (α : Type) : ∀ x : α, x = x := by
  intro x --arbitrary element of α
  exact Eq.refl x --get x=x

/-
You can use it to introduce several variables:
-/
example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intro a b c h₁ h₂
  --introing arbitrary a,b,c :Nat
  --introing a = b as h₁ and a = c as h₂
  exact Eq.trans (Eq.symm h₂) h₁ --transitivity on Eq.symm h₂: c = a and a = b

/-
As the apply tactic is a command for constructing function applications interactively,
the intro tactic is a command for constructing function abstractions interactively
(i.e., terms of the form fun x => e).

As with lambda abstraction notation, the intro tactic allows us to use an implicit match.
-/
example (α : Type) (p q : α → Prop) : (∃ x, p x ∧ q x) → ∃ x, q x ∧ p x := by
  intro ⟨w, hpw, hqw⟩ -- introducing the w that has pw and px
  exact ⟨w, hqw, hpw⟩ -- using exists intro and swapping the order

/-
You can also provide multiple alternatives like in the match expression.
-/

example (α : Type) (p q : α → Prop) : (∃ x, p x ∨ q x) → ∃ x, q x ∨ p x := by
  intro
  | ⟨w, Or.inl h⟩ => exact ⟨w, Or.inr h⟩
  | ⟨w, Or.inr h⟩ => exact ⟨w, Or.inl h⟩

/-
The intros tactic can be used without any arguments, in which case,
it chooses names and introduces as many variables as it can.

You will see an example of this in a moment.

The assumption tactic looks through the assumptions in context of the current goal,
and if there is one matching the conclusion, it applies it.
-/

example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans h₁ --applying to h₁ leaves needing a y=w
  apply Eq.trans h₂ --aplying again to h₂ , needs z=w
  assumption   -- applied h₃, which is z=w


/-
It will unify metavariables in the conclusion if necessary:
-/

example (x y z w : Nat) (h₁ : x = y) (h₂ : y = z) (h₃ : z = w) : x = w := by
  apply Eq.trans --no args, but need result x=w, so need x= ?b first
  assumption      -- solves x = ?b with h₁
  apply Eq.trans
  assumption      -- solves y = ?h₂.b with h₂, i.e ?h₂.b = z
  assumption      -- solves z = w with h₃

/-
The following example uses the intros command to introduce the three variables
and two hypotheses automatically:
-/

example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros --introducing a b c , a=b, a=c
  apply Eq.trans
  apply Eq.symm
  assumption
  assumption

/-
Note that names automatically generated by Lean are inaccessible by default.

The motivation is to ensure your tactic proofs do not rely on automatically generated names,
and are consequently more robust.

However, you can use the combinator unhygienic to disable this restriction.
-/

example : ∀ a b c : Nat, a = b → a = c → c = b := by unhygienic
  intros
  apply Eq.trans
  apply Eq.symm
  exact a_2
  exact a_1


/-
You can also use the rename_i tactic to rename the most recent inaccessible names in your context.

In the following example, the tactic rename_i h1 _ h2 renames two of the
last three hypotheses in your context.
-/

example : ∀ a b c d : Nat, a = b → a = d → a = c → c = b := by
  intros
  rename_i h1 _ h2
  apply Eq.trans
  apply Eq.symm
  exact h2
  exact h1

/-
The rfl tactic is syntactic sugar for exact rfl:
-/

example (y : Nat) : (fun x : Nat => 0) y = 0 :=
  by rfl

/-
The repeat combinator can be used to apply a tactic several times:
-/

example : ∀ a b c : Nat, a = b → a = c → c = b := by
  intros
  apply Eq.trans
  apply Eq.symm
  repeat assumption

/-
Another tactic that is sometimes useful is the revert tactic, which is, in a sense, an inverse to intro:
-/
example (x : Nat) : x = x := by
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl

/-
Moving a hypothesis into the goal yields an implication:
-/
example (x y : Nat) (h : x = y) : y = x := by
  revert h
  -- goal is x y : Nat ⊢ x = y → y = x
  intro h₁
  -- goal is x y : Nat, h₁ : x = y ⊢ y = x
  apply Eq.symm
  assumption

/-
But revert is even more clever, in that it will revert not only an element of
the context but also all the subsequent elements of the context that depend on it.

For example, reverting x in the example above brings h along with it:
-/

example (x y : Nat) (h : x = y) : y = x := by
  revert x
  -- goal is y : Nat ⊢ ∀ (x : Nat), x = y → y = x
  -- reverts both h and x
  intros
  apply Eq.symm
  assumption

/-
You can also revert multiple elements of the context at once:
-/
example (x y : Nat) (h : x = y) : y = x := by
  revert x y
  -- goal is ⊢ ∀ (x y : Nat), x = y → y = x
  intros
  apply Eq.symm
  assumption

/-
You can only revert an element of the local context, that is, a local variable or hypothesis.

But you can replace an arbitrary expression in the goal by a fresh variable
using the generalize tactic:
-/
example : 3 = 3 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ x = x
  revert x
  -- goal is ⊢ ∀ (x : Nat), x = x
  intro y
  -- goal is y : Nat ⊢ y = y
  rfl

/-
The mnemonic in the notation above is that you are generalizing the goal by
setting 3 to an arbitrary variable x.

Be careful: not every generalization preserves the validity of the goal.

Here, generalize replaces a goal that could be proved using rfl with one that
is not provable:
-/
example : 2 + 3 = 5 := by
  generalize 3 = x
  -- goal is x : Nat ⊢ 2 + x = 5
  admit

/-
In this example, the admit tactic is the analogue of the sorry proof term.

It closes the current goal, producing the usual warning that sorry has been used.

To preserve the validity of the previous goal, the generalize tactic allows us
to record the fact that 3 has been replaced by x.

All you need to do is to provide a label, and generalize uses it to store
the assignment in the local context:
-/
example : 2 + 3 = 5 := by
  generalize h : 3 = x
  -- goal is x : Nat, h : 3 = x ⊢ 2 + x = 5
  rw [← h]
/-
Here the rewrite tactic, abbreviated rw, uses h to replace x by 3 again.

The rewrite tactic will be discussed below.
-/
